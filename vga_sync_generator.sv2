module vga_sync_generator
(
	input	wire		clk,
	input	wire		reset,
	output	reg		h_sync,
	output	reg		v_sync,
	output	reg		blank_n,
	output	reg	[10:0]	next_x,
	output	reg	[ 9:0]	next_y
);

`include "vga_sync_timing.svh"

reg [10:0] h_count;
reg [ 9:0] v_count;

logic h_active;
logic v_active;

/*
 * DAC Blanking Signal
 */
always_ff @(posedge clk or posedge reset) : proc_vga_blank
{
	if (reset)
		blank_n <= 0;
	else
		blank_n <= h_active && v_active;
}

/*
 * VGA Horizontal Timing State Machine
 */
always_ff @(posedge clk or posedge reset) : proc_vga_h
{
	if (reset)
	{
		h_count <= 1'b0;
		next_x  <= 1'b0;
		h_sync  <= 1'b1;

		h_active <= 0;
	}
	else
	{
		h_count <= (h_count == `LINE-1) ? 0 : h_count + 1;
		h_sync  <= (h_count < `H_PULSE) ? 0 : 1;

		next_x  <= (h_count < `H_PULSE + `H_BACK) ? 0 : next_x + 1;

		/* H_ACTIVE (BLANK_N) */
		if (h_count == `H_PULSE + `H_BACK)
			h_active <= 1;
		else if (h_count == `LINE - `H_FRONT)
			h_active <= 0;
		else
			h_active <= h_active;
	}
} // proc_vga_h

/*
 * VGA Vertical Timing State Machine
 */
always_ff @(posedge clk or posedge reset) : proc_vga_v
{
	if (reset)
	{
		v_count <= 1'b0;
		next_y  <= 1'b0;
		v_sync  <= 1'b1;

		v_active <= 1'b0;
	}
	else
	{
		v_sync <= (v_count < `V_PULSE) ? 0 : 1;

		if (h_count == `LINE-1)
		{
			v_count <= (v_count == `SCREEN-1) ? 0 : v_count + 1;

			if (v_count < `V_PULSE + `V_BACK)
				next_y <= 0;
			else
				next_y <= next_y + 1;
		}

		/* V_ACTIVE (BLANK_N) */
		if (v_count == `V_PULSE + `V_BACK)
			v_active <= 1;
		else if (v_count == `SCREEN - `V_FRONT)
			v_active <= 0;
		else
			v_active <= v_active;
	}
} // prov_vga_v

endmodule
